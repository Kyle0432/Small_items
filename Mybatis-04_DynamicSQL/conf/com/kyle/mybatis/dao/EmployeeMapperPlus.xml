<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 
 <mapper namespace="com.kyle.mybatis.dao.EmployeeMapperPlus">
 
 <!-- 
           自定义某个javaBean的封装规则
     type:自定义规则的java类型   
     id:唯一id方便引用   
  -->
 <resultMap type="com.kyle.mybatis.helloworld.Employee" id="myEasyEmp">
 <!-- 指定主键列的封装规则 
    id标签定义主键会在底层有优化
    column:指定哪一列
    property:指定对应的javaBean属性
 -->
 <id column="id" property="id"/>
 <!-- 定义普通列封装规则 -->
 <result column="last_name" property="lastName"/>
 <!-- 
          其他不指定的列会自动封装,我们只要写resultMap就把全部的映射规则都写上
          其主要是解决为那些javabean里的属性不和数据库字段对应的,其他对应可省略
  -->
 <result column="email" property="email"/>
 <result column="gender" property="gender"/>
 </resultMap>
 
 <!-- resultMap:自定义结果集映射规则-->
 <!--public Employee getEmpById(Integer id); -->
 <select id="getEmpById" resultMap="myEasyEmp">
 select * from employee where id = #{id}
 </select>

  <!-- 
     场景一:
     查询Employee的同时查询员工对应的部门
  Employee ==== Department
     一个员工与之对应的部门信息
     id last_name gender d_id department_name
   -->
   <!-- 
       级联查询,级联属性封装结果
    -->
<!-- public Employee getEmpAndDept(Integer id); -->
<resultMap type="com.kyle.mybatis.helloworld.Employee" id="myDifEmp">
<id column="id" property="id"/>
<result column="last_name" property="lastName"/>
<result column="email" property="email"/>
<result column="gender" property="gender"/>
<result column="d_id" property="dept.id"/>
<result column="department_name" property="dept.departmentName"/>
</resultMap>


        <!--     【一对一操作】
             使用association定义单个对象的封装规则 -->
<resultMap type="com.kyle.mybatis.helloworld.Employee" id="myDifEmp2">
<id column="id" property="id"/>
<result column="last_name" property="lastName"/>
<result column="email" property="email"/>
<result column="gender" property="gender"/>
<!-- association可以指定联合的javaBean对象
   property="dept"指定哪个属性是联合的对象
   javaType:指定这个属性对象的类型[不能省略]
 -->
<association property="dept" javaType="com.kyle.mybatis.helloworld.Department">
  <!--property="id"是在javaType类型下的id  -->
  <id column="d_id" property="id"/>
  <result column="department_name" property="departmentName"/>
</association>
</resultMap>
<select id="getEmpAndDept" resultMap="myDifEmp2">
<!-- 进行了多表查询 -->
select e.id id,e.last_name last_name,e.email email,
e.gender gender,e.department_id d_id,
d.id d_id,d.department_name department_name 
from employee e,department d
where e.department_id = d.id and e.id = #{id}
</select>


<!-- 使用association进行分步查询
    1，先按照员工id查询员工信息
    2,根据查询员工信息中的d_id值去部门表查出部门信息
    3,部门设置到员工中
 -->
 <resultMap type="com.kyle.mybatis.helloworld.Employee" id="MyEmpByStep">
 <id column="id" property="id"/>
 <result column="last_name" property="lastName"/>
 <result column="email" property="email"/>
 <result column="gender" property="gender"/>
<!-- assocation定义关联对象的封装 
     select:表明当前属性是调用select指定的方法查出的结果
     column:指定将哪一列的值传给这个方法
流程:使用select指定的方法(传入column指定的这列参数的值)查出对象,并封装给property指定的属性
-->
 <association property="dept" select="com.kyle.mybatis.dao.DepartmentMapper.getDeptById"
             column="id">
 </association>
 </resultMap>
 <!-- public Employee getEmpByIdStep(Integer id); -->
<select id="getEmpByIdStep" resultMap="MyEmpByStep">
select * from employee where id = #{id}
</select>
<!-- 
    可以使用延迟加载
  Employee  === Dept
    我们每次查询Employee对象时候,都将一起查询出来
    部门信息在我们使用的时候再去查询
    在分段查询的基础上加上两个配置
 -->
 <!-- ============================================================ -->
 <!-- 
           场景二:
           查询部门的时候将部门对应的所有员工信息也查询出来
 
 
  -->
  
 <!-- public List<Employee> getEmpsByDeptId(Integer deptId); -->
 <select id="getEmpsByDeptId" resultType="com.kyle.mybatis.helloworld.Employee">
         select * from employee where department_id = #{dept_id}
 </select>
 
 <!-- 
     <discriminator javaType = ""></discriminator>
           鉴别器:mybatis可以使用discriminator判断某列的值,然后根据某列的值修改封装行为
        封装Employee 
             如果查出的是女生,就把部门信息查询出来,否则不查询
             如果是男生,把last_name这一列的值赋值给email    
 
  -->
  
 </mapper>